# -*- coding: utf-8 -*-
"""MachineLearning_Iris

#Valentina Julieth Sandoval Tarazona 
#Laura Milena Laiton Rodríguez

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SXYNhvCZ1w7b6wMCioHtsnZsvXtlGbec
"""

import pandas as pd
from sklearn.datasets import load_iris

iris = load_iris(as_frame=True)

dataset = iris.frame

print(dataset)

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from sklearn import datasets
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

# Cargar dataset iris
iris = datasets.load_iris()
X = iris.data[:, :2]   # Solo sépalos
y = iris.target
target_names = iris.target_names

# Dividir dataset en 70% y 30%
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# Entrenar modelo de REGRESIÓN LINEAL
model = LinearRegression()
model.fit(X_train, y_train)

# Predicciones 
y_pred_continuo = model.predict(X_test)

# Convertir a clases redondeando
y_pred = np.round(y_pred_continuo).astype(int)

# valores estén en [0, 2]
y_pred = np.clip(y_pred, 0, 2)

# Métricas
print("Accuracy:", accuracy_score(y_test, y_pred))
print("\nReporte de clasificación:\n", classification_report(y_test, y_pred, target_names=target_names))

# ---------------- MATRIZ DE CONFUSIÓN ----------------
plt.figure(figsize=(5,4))
sns.heatmap(confusion_matrix(y_test, y_pred), annot=True, fmt="d", cmap="Oranges",
            xticklabels=target_names, yticklabels=target_names)
plt.title("Matriz de Confusión (Regresión Lineal)")
plt.xlabel("Predicción")
plt.ylabel("Real")
plt.show()

# ---------------- GRÁFICO DE FRONTERAS ----------------
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.02),
                     np.arange(y_min, y_max, 0.02))

# Predicciones en toda la grilla
Z_continuo = model.predict(np.c_[xx.ravel(), yy.ravel()])
Z = np.round(Z_continuo).astype(int)
Z = np.clip(Z, 0, 2)
Z = Z.reshape(xx.shape)

plt.figure(figsize=(8, 6))
plt.contourf(xx, yy, Z, alpha=0.4, cmap=plt.cm.Set1)
plt.scatter(X[:, 0], X[:, 1], c=y, edgecolor="k", cmap=plt.cm.Set1)
plt.xlabel("Largo del sépalo (cm)")
plt.ylabel("Ancho del sépalo (cm)")
plt.title("Clasificación forzada con Regresión Lineal (Iris - Sépalos)")
plt.show()
